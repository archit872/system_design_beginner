<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Ch. 4 — Caching & Performance Basics</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="What caching is, why it helps, cache placement options (browser, CDN, server-side), and cache invalidation patterns with concrete examples and trade-offs.">
  <meta property="og:title" content="Chapter 4 — Caching & Performance Basics">
  <meta property="og:description" content="Speed up reads with browser, CDN, and server-side caches. Learn TTLs, freshness, and invalidation patterns—plus when caching hurts.">
  <base href="../">
  <link rel="stylesheet" href="styles/theme.css">
  <script src="scripts/app.js" defer></script>
</head>
<body>
  <a class="skip-link" href="#main">Skip to content</a>

  <!-- Canonical Navigation (copy verbatim across all pages) -->
  <nav class="app-nav">
    <div class="container inner">
      <div class="brand">System Design (Beginner)</div>
      <button class="toggle js-nav-toggle" aria-expanded="false" aria-controls="site-menu" aria-label="Toggle menu">☰ Menu</button>
      <div id="site-menu" class="menu" role="navigation" aria-label="Primary">
        <a href="index.html">Home</a>
        <a href="chapters/ch01.html">Chapters</a>
        <a href="chapters/appendix.html">Appendix</a>
        <a href="chapters/glossary.html">Glossary</a>
      </div>
    </div>
  </nav>

  <header class="page-hero" id="top">
    <div class="container">
      <div class="meta">
        <span class="badge badge-primary">Chapter 4</span>
        <span class="badge">Performance</span>
      </div>
      <h1>Caching &amp; Performance Basics</h1>
      <p class="abstract">Caching reduces <abbr title="Time from request to response">latency</abbr> and increases <abbr title="Units of work per second">throughput</abbr> by reusing results of previous work. This chapter explains where caches live—browser, CDN, server-side—and how to control <abbr title="How fresh a cached representation is considered">freshness</abbr>, choose <abbr title="Time To Live—how long an object is allowed to be cached">TTLs</abbr>, and avoid the classic hardest problem in CS: cache invalidation.</p>
    </div>
  </header>

  <main id="main" class="container section">
    <section class="section" aria-labelledby="prereqs">
      <h2 id="prereqs">Prerequisites &amp; Learning Objectives</h2>
      <div class="grid two">
        <div class="card">
          <h3 class="mt-0">Prerequisites</h3>
          <ul>
            <li>Chapter 2 (HTTP basics, request/response) and Chapter 3 (read paths, indexes).</li>
            <li>Ability to run a simple web server locally.</li>
          </ul>
        </div>
        <div class="card">
          <h3 class="mt-0">Objectives</h3>
          <ul>
            <li>Explain the purposes and placements of caches (browser, CDN, server-side).</li>
            <li>Use HTTP caching headers (<code>Cache-Control</code>, <code>ETag</code>, <code>Last-Modified</code>) appropriately.</li>
            <li>Evaluate server-side caching with Redis/Memcached and pick cache keys/TTLs.</li>
            <li>Apply invalidation patterns (TTL, write-through, write-back, event-driven busting) and reason about trade-offs.</li>
          </ul>
        </div>
      </div>
    </section>
    <section class="section" aria-labelledby="intro">
      <h2 id="intro">4.1 Introduction to Caching</h2>
      <p>A <strong>cache</strong> stores the result of expensive operations so future requests can be answered faster. We trade <em>freshness</em> for <em>speed</em> under explicit rules. Good caches are predictable: you should be able to answer “when does this change propagate?”</p>
      <p><strong>Analogy:</strong> Think of a café that pre-brews popular drinks before rush hour. Most customers get served instantly; a few special orders take longer. If the pre-brew sits too long, quality drops—so the café discards it after 20 minutes (TTL) and brews fresh.</p>
      <p><strong>Example:</strong> A product page composes static assets (HTML, CSS, images) and dynamic data (price, stock). Static assets cache for days at the CDN; dynamic fragments cache for seconds on the server to withstand bursts while remaining fresh.</p>
      <div class="callout warn">
        <span class="icon">⚠️</span>
        <strong>Pitfall:</strong> “Cache everything” without a plan for invalidation leads to stale views, missed updates, and support tickets. Start with hot, read-heavy endpoints and short, safe TTLs.
      </div>
    </section>

    <section class="section" aria-labelledby="browser-cdn">
      <h2 id="browser-cdn">4.2 Browser Cache &amp; CDN Basics</h2>
      <div class="grid two">
        <div class="card">
          <h3 class="mt-0">HTTP Caching 101</h3>
          <ul>
            <li><code>Cache-Control: max-age=86400, public</code> — allow intermediaries to cache for a day.</li>
            <li><code>ETag</code> / <code>If-None-Match</code> — validators for conditional requests (304 Not Modified).</li>
            <li><code>Last-Modified</code> / <code>If-Modified-Since</code> — time-based validator.</li>
            <li><code>Vary</code> — separate caches by header (e.g., <code>Accept-Encoding</code>, <code>Authorization</code>).</li>
          </ul>
        </div>
      </div>
      <p><strong>Immutable file strategy:</strong> Fingerprint assets (e.g., <code>main.abcd1234.css</code>) and serve with <code>Cache-Control: public, max-age=31536000, immutable</code>. Deploys upload new files; HTML references change the filenames. This gives you long-lived caching without manual purges.</p>
      <p><strong>Personalized pages:</strong> Avoid caching entire responses at the CDN when they vary per user. Instead, cache static parts and fetch personalized JSON separately, or use <abbr title="Edge execution like CDN workers to compose cached and dynamic data">edge compute</abbr>.</p>
    </section>

    <section class="section" aria-labelledby="server-cache">
      <h2 id="server-cache">4.3 Server-side Caching with Redis/Memcached</h2>
      <p>Server-side caches (in-process or shared like <strong>Redis</strong>/<strong>Memcached</strong>) absorb hot reads and smooth write bursts. A shared cache allows multiple app replicas to reuse results. Typical patterns:</p>
      <ul>
        <li><strong>Cache-aside (lazy loading):</strong> App checks cache; on miss, loads from DB and stores in cache with TTL.</li>
        <li><strong>Write-through:</strong> On write, synchronously update cache and DB; reads always hit cache.</li>
        <li><strong>Write-back (write-behind):</strong> Writes go to cache and are flushed to DB asynchronously—low latency but risk data loss on crash.</li>
      </ul>
      <div class="grid two">
        <div class="card">
          <h3 class="mt-0">Choosing Keys &amp; TTLs</h3>
          <ul>
            <li>Keys mirror access paths: <code>user:{id}:profile</code>, <code>conv:{id}:recent:page:{n}</code>.</li>
            <li>Set <strong>short TTLs</strong> for dynamic data (5–120 s), <strong>long TTLs</strong> for static metadata.</li>
            <li>Add <em>jitter</em> (±20%) to TTLs to avoid synchronized expiry (“cache stampede”).</li>
          </ul>
        </div>
      </div>
      <div class="callout info">
        <strong>Stampede control:</strong> Use <em>request coalescing</em> (only one worker recomputes a missing key) and <em>soft TTLs</em> (serve slightly stale while refreshing in background).
      </div>
      <div class="callout warn">
        <span class="icon">⚖️</span>
        <strong>Trade-off:</strong> Write-through increases write latency but guarantees fresh cache. Cache-aside is simpler but risks brief staleness after writes. Write-back reduces write latency but can lose data without durable queues.
      </div>
    </section>

    <section class="section" aria-labelledby="invalidation">
      <h2 id="invalidation">4.4 Cache Invalidation Patterns</h2>
      <p>Invalidation answers: <em>When should the cache stop serving a value?</em> Strategies vary by data volatility and correctness needs.</p>
      <h3 id="ttl">TTL (Time To Live)</h3>
      <p>Let entries expire naturally after N seconds. Best for data that can be slightly stale (leaderboards, trending lists). Add jitter to avoid herd effects.</p>

      <h3 id="purge">Explicit Purge / Bust</h3>
      <p>When authoritative data changes, actively delete/expire the cache entry (e.g., <code>DEL</code> in Redis or CDN API purge). Requires knowing all affected keys.</p>

      <h3 id="versioning">Versioned Keys</h3>
      <p>Include a <em>version</em> or <em>content hash</em> in the key (e.g., <code>product:{id}:v42</code>). Writes bump the version; readers never serve mixed states. Works well for immutable assets and materialized views.</p>

      <h3 id="events">Event-driven Invalidation</h3>
      <p>Emit domain events (“price-updated”, “profile-changed”) and subscribe to invalidate or recompute affected entries. Scales well across services but requires reliable delivery and idempotent handlers.</p>

      <div class="grid two">
        <div class="card">
          <h3 class="mt-0">What not to cache</h3>
          <ul>
            <li>Highly personalized data without a stable key strategy.</li>
            <li>Security-sensitive artifacts (unless you handle revocation/expiry correctly).</li>
            <li>Rarely accessed data (caching adds complexity without payoff).</li>
          </ul>
        </div>
        <div class="card">
          <h3 class="mt-0">Eviction Policies</h3>
          <ul>
            <li><strong>LRU</strong> (Least Recently Used) — good general default.</li>
            <li><strong>LFU</strong> (Least Frequently Used) — favors hot keys over time.</li>
            <li><strong>TTL-based</strong> — combine with LRU/LFU to cap staleness.</li>
          </ul>
        </div>
      </div>
    </section>

    <section class="section" aria-labelledby="compare">
      <h2 id="compare">Compare &amp; Contrast: CDN vs. Server Cache</h2>
      <table>
        <thead><tr><th>Aspect</th><th>CDN (Edge)</th><th>Server-side Cache</th></tr></thead>
        <tbody>
          <tr><td>Scope</td><td>Static assets, cacheable API GETs</td><td>Dynamic fragments, computed views</td></tr>
          <tr><td>Latency</td><td>Very low (near user)</td><td>Low (in-datacenter)</td></tr>
          <tr><td>Freshness control</td><td>HTTP headers, purge APIs</td><td>TTL, explicit bust, versioned keys</td></tr>
          <tr><td>Personalization</td><td>Hard (Vary, cookies)</td><td>Easier (fine-grained keys)</td></tr>
          <tr><td>Cost</td><td>Bandwidth + edge storage</td><td>Memory + ops on Redis/Memcached</td></tr>
        </tbody>
      </table>
    </section>

    <section class="section" aria-labelledby="case">
      <h2 id="case">Case Study: Speeding Up a Product Page (≈200 words)</h2>
      <p>A retailer’s product page is slow at peak—median 450 ms, p95 1.8 s. Profiling shows three hotspots: image delivery, price lookup, and “related products.” The team deploys three targeted caches. First, <strong>CDN</strong> for images and static assets with immutable fingerprints and 30-day TTL; HTML remains short-TTL to avoid stale layouts. Second, a <strong>server-side cache</strong> (<code>product:{id}:summary</code>) for high-traffic attributes (title, rating, primary price) with a 60 s TTL + jitter and request coalescing; price updates publish an “price-updated” event to bust specific keys. Third, a <strong>materialized view</strong> for “related products” recomputed via background jobs and versioned keys (e.g., <code>rel:{id}:vN</code>) to avoid mixed results during deploys.</p>
      <p>Results: CDN reduces image bytes by 80% and cuts TTFB for static assets to ~20 ms at the edge. Server cache hits ~85% during peak, bringing the median to 180 ms and p95 to 600 ms. Correctness is protected by short TTLs and event-driven busts. Operational guardrails include dashboards for hit rate, eviction, stampede alerts, and a kill-switch to bypass caches during incidents.</p>
    </section>

    <section class="section" aria-labelledby="resources">
      <h2 id="resources">Resources</h2>
      <ul class="resource-list">
        <li class="item">
          <div>
            <a class="external" href="https://redis.io/docs/latest" target="_blank">Redis Documentation</a>
            <div class="meta">Data structures, eviction policies, clustering, and persistence options for server-side caching.</div>
          </div>
          <span class="badge">Server Cache</span>
        </li>
        <li class="item">
          <div>
            <a class="external" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching" target="_blank">MDN — HTTP Caching</a>
            <div class="meta">Authoritative guidance on headers, validators, and caching semantics.</div>
          </div>
          <span class="badge">HTTP</span>
        </li>
        <li class="item">
          <div>
            <a class="external" href="https://www.cloudflare.com/learning/cdn/what-is-caching/" target="_blank">Cloudflare — What is Caching?</a>
            <div class="meta">CDN perspectives on edge caching and performance trade-offs.</div>
          </div>
          <span class="badge">CDN</span>
        </li>
      </ul>
    </section>

    <section class="section practice" aria-labelledby="practice">
      <div class="title">Practice <span class="badge">30–50 min</span></div>
      <h2 id="practice" class="mt-1">Hands-on Tasks</h2>
      <ol>
        <li><strong>Header tune-up (10–15 min).</strong> Serve a static image and HTML from your local server. Add <code>Cache-Control</code> and <code>ETag</code>. <em>Success:</em> Browser devtools show 304 responses on reload; CDN-sim tool (or curl) reveals correct headers.</li>
        <li><strong>Cache-aside (10–15 min).</strong> Wrap one read-heavy API in a Redis/Memcached cache. Choose a key and TTL with ±20% jitter. <em>Success:</em> 80%+ hit rate on a simulated burst; DB queries drop accordingly.</li>
        <li><strong>Stampede guard (5–10 min).</strong> Implement request coalescing so only one worker recomputes a missing key. <em>Success:</em> Under 50 concurrent requests for a cold key, only one DB query executes.</li>
        <li><strong>Invalidation drill (10–15 min).</strong> Add a “product-updated” event that purges related cache keys. <em>Success:</em> API returns fresh data within 1–2 s of update.</li>
      </ol>
    </section>

    <section class="section mastery" aria-labelledby="mastery">
      <div class="title">Mastery Check <span class="badge">Self-assessment</span></div>
      <h2 id="mastery" class="mt-1">Questions (with sample answers)</h2>

      <details>
        <summary>1) What’s the trade-off between longer TTLs and data freshness?</summary>
        <div class="pad-2">
          <p><strong>Sample answer:</strong> Longer TTLs increase hit rate and reduce origin load, improving latency and throughput, but risk serving stale data after updates. Balance by using short TTLs for volatile data and explicit busting for critical updates.</p>
        </div>
      </details>

      <details>
        <summary>2) Compare cache-aside vs. write-through.</summary>
        <div class="pad-2">
          <p><strong>Sample answer:</strong> Cache-aside loads on miss and may serve stale data right after a write; it’s simple and low-latency for writes. Write-through updates cache and DB on writes, keeping reads fresh at the cost of higher write latency and more failure modes.</p>
        </div>
      </details>

      <details>
        <summary>3) Why add jitter to TTLs?</summary>
        <div class="pad-2">
          <p><strong>Sample answer:</strong> To avoid synchronized expiry where many keys die at once, causing a thundering herd of recomputations and DB load spikes.</p>
        </div>
      </details>

      <details>
        <summary>4) When should you avoid CDN caching?</summary>
        <div class="pad-2">
          <p><strong>Sample answer:</strong> When responses are highly personalized or authorization-dependent and can’t be safely partitioned by headers/cookies, or when correctness requires real-time freshness that TTLs/purges can’t guarantee.</p>
        </div>
      </details>

      <details>
        <summary>5) Give an example of versioned keys and why they help during deploys.</summary>
        <div class="pad-2">
          <p><strong>Sample answer:</strong> <code>rel:{productId}:v37</code> where a background job computes related items. When the algorithm changes, bump to <code>v38</code>; readers switch atomically, avoiding mixed results while old entries expire naturally.</p>
        </div>
      </details>

      <details>
        <summary>6) What metrics indicate a healthy cache?</summary>
        <div class="pad-2">
          <p><strong>Sample answer:</strong> High hit rate for targeted endpoints, reduced DB QPS, lower p95 latency, stable memory usage, low eviction of hot keys, and absence of stampede spikes during traffic bursts.</p>
        </div>
      </details>
    </section>

    <section class="section" aria-labelledby="recap">
      <h2 id="recap">Recap &amp; Next Steps</h2>
      <p><strong>Recap:</strong> You learned where to place caches, how to configure HTTP and server-side caches, and how to invalidate safely. You practiced choosing keys/TTLs, preventing stampedes, and purging entries on updates.</p>
      <p><strong>Next:</strong> In <a href="chapters/ch05.html">Chapter 5</a>, we scale the system horizontally, introduce load balancers, and learn how to identify and relieve bottlenecks.</p>
    </section>

    <nav class="next-prev" aria-label="Chapter pager">
      <a rel="prev" href="chapters/ch03.html">Previous: Storage &amp; Databases Fundamentals</a>
      <a rel="next" href="chapters/ch05.html">Next: Scalability &amp; Load Handling</a>
    </nav>
  </main>

  <footer class="site-footer">
    <div class="container">
      <p class="mb-0">© 2025 System Design (Beginner). Chapter 4.</p>
    </div>
  </footer>

  <!--
  CHECKLIST (do not remove)
  - [x] /styles/theme.css + /scripts/app.js linked (paths correct for /chapters/)
  - [x] <base href="../"> present & correct
  - [x] Canonical nav verbatim; active link via app.js
  - [x] Pager prev=ch03, next=ch05
  - [x] Sections meet depth: 4.1–4.4 + examples, compare/contrast, analogy, trade-off
  - [x] Practice (3–4 tasks) with time + success criteria
  - [x] Mastery (5–7 Qs) with sample answers
  - [x] ≥8 glossary-style terms via <abbr> (latency, throughput, TTL, freshness, edge compute, cache-aside, write-through, write-back)
  - [x] Recap + Next steps
  -->
</body>
</html>
