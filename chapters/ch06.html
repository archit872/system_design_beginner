<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Ch. 6 — Reliability & Fault Tolerance</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="Design for failure: redundancy, failover, disaster recovery, monitoring, logging, and alerting. Learn patterns that keep systems running under faults.">
  <meta property="og:title" content="Chapter 6 — Reliability & Fault Tolerance">
  <meta property="og:description" content="Redundancy, failover, DR, SLIs/SLOs, alerts, and fault-tolerant patterns like retries, timeouts, and circuit breakers.">
  <base href="../">
  <link rel="stylesheet" href="styles/theme.css">
  <script src="scripts/app.js" defer></script>
</head>
<body>
  <a class="skip-link" href="#main">Skip to content</a>

  <!-- Canonical Navigation (copy verbatim across all pages) -->
  <nav class="app-nav">
    <div class="container inner">
      <div class="brand">System Design (Beginner)</div>
      <button class="toggle js-nav-toggle" aria-expanded="false" aria-controls="site-menu" aria-label="Toggle menu">☰ Menu</button>
      <div id="site-menu" class="menu" role="navigation" aria-label="Primary">
        <a href="index.html">Home</a>
        <a href="chapters/ch01.html">Chapters</a>
        <a href="chapters/appendix.html">Appendix</a>
        <a href="chapters/glossary.html">Glossary</a>
      </div>
    </div>
  </nav>

  <header class="page-hero" id="top">
    <div class="container">
      <div class="meta">
        <span class="badge badge-primary">Chapter 6</span>
        <span class="badge">Reliability</span>
      </div>
      <h1>Reliability &amp; Fault Tolerance</h1>
      <p class="abstract">Reliable systems assume components will fail and still deliver acceptable service. You’ll learn redundancy and <abbr title="Automatic switch to a standby component when the primary fails">failover</abbr> patterns, <abbr title="Disaster Recovery: policies and architecture to survive regional outages">DR</abbr> strategies, and the basics of <abbr title="Monitoring: metrics; Logging: textual records; Tracing: request flows">monitoring, logging, and tracing</abbr>—all governed by measurable <abbr title="Service Level Indicators and Objectives">SLIs/SLOs</abbr> and budgets.</p>
    </div>
  </header>

  <main id="main" class="container section">
    <section class="section" aria-labelledby="prereqs">
      <h2 id="prereqs">Prerequisites &amp; Learning Objectives</h2>
      <div class="grid two">
        <div class="card">
          <h3 class="mt-0">Prerequisites</h3>
          <ul>
            <li>Chapter 3 (replication basics) and Chapter 5 (load balancing, statelessness).</li>
            <li>Basic understanding of HTTP request flows and caches.</li>
          </ul>
        </div>
        <div class="card">
          <h3 class="mt-0">Objectives</h3>
          <ul>
            <li>Define <abbr title="Uptime percentage over a window">availability</abbr>, <abbr title="Probability that acknowledged data is not lost">durability</abbr>, and how they differ.</li>
            <li>Design redundancy and failover at each tier (LB, app, cache, DB).</li>
            <li>Plan disaster recovery with recovery <abbr title="Recovery Time Objective — how long you can be down">RTO</abbr> and <abbr title="Recovery Point Objective — acceptable data loss window">RPO</abbr> targets.</li>
            <li>Set <abbr title="Measurable indicators (SLIs) and goals (SLOs) for service quality">SLIs/SLOs</abbr> and wire up monitoring, logging, and alerting.</li>
          </ul>
        </div>
      </div>
    </section>

    <figure>
      <img src="assets/reliability-layers.svg" alt="Stack diagram showing reliability at layers: DNS, CDN/Edge, Load Balancer, App, Cache, Database, Queue, Storage, with redundancy arrows" />
      <figcaption>Reliability is layered: redundancy and failover should exist at DNS, edge, compute, caches, data stores, and queues—each with health checks and timeouts.</figcaption>
    </figure>

    <section class="section" aria-labelledby="fail">
      <h2 id="fail">6.1 Why Systems Fail</h2>
      <p>Failures are <strong>normal</strong>: disks die, networks partition, processes crash, and humans misconfigure. Designing for reliability means assuming failure and making it <em>contained</em>, <em>observable</em>, and <em>recoverable</em>. Common failure modes:</p>
      <div class="grid two">
        <div class="card">
          <h3 class="mt-0">Typical Faults</h3>
          <ul>
            <li><strong>Hardware:</strong> disk/CPU/memory faults; <abbr title="Power, cooling, or rack-level outages">datacenter</abbr> incidents.</li>
            <li><strong>Network:</strong> packet loss, <abbr title="Loss of communication between nodes">partitions</abbr>, DNS/cert expiry.</li>
            <li><strong>Software:</strong> memory leaks, deadlocks, slow GC, dependency timeouts.</li>
            <li><strong>Operations:</strong> bad deploys, schema migrations, expired credentials.</li>
          </ul>
        </div>
        <div class="card">
          <h3 class="mt-0">Containment Tactics</h3>
          <ul>
            <li>Timeouts on every hop; <abbr title="Retry with exponentially increasing intervals and jitter to avoid herd effects">exponential backoff with jitter</abbr>.</li>
            <li><abbr title="A protective switch that stops calls to a failing dependency">Circuit breakers</abbr> and <abbr title="Limit the rate of requests to preserve service">rate limits</abbr>.</li>
            <li>Bulkheads: isolate pools/threads per dependency to prevent cascading failures.</li>
            <li>Graceful degradation: serve cached or partial results during incidents.</li>
          </ul>
        </div>
      </div>
      <div class="callout info">
        <strong>Analogy:</strong> Ships are divided into watertight compartments (bulkheads) so a hull breach doesn’t sink the vessel. Services need bulkheads across threads, connections, and queues.
      </div>
    </section>

    <section class="section" aria-labelledby="redundancy">
      <h2 id="redundancy">6.2 Replication, Redundancy &amp; Backups</h2>
      <p>Reliability starts with eliminating single points of failure (SPOFs). Provide at least N+1 capacity for critical components and <strong>health-check</strong> everything.</p>

      <figure>
        <img src="assets/redundancy-patterns.svg" alt="Patterns: active-active, active-passive, and N+1 for app and database tiers, with arrows showing failover" />
        <figcaption>Active–active maximizes capacity and failover speed; active–passive reduces cost but increases failover time; N+1 ensures spare capacity during maintenance or incidents.</figcaption>
      </figure>

      <h3 id="active-active">Active–Active</h3>
      <p>Multiple replicas serve traffic simultaneously. If one fails, others absorb load. Requires <abbr title="Consistent view of cluster membership and health">distributed coordination</abbr>, and for stateful systems, careful replication to avoid split brain.</p>

      <h3 id="active-passive">Active–Passive</h3>
      <p>A hot or warm standby takes over when primary fails. Simpler for databases with leader/follower replication. Failover can be automatic or manual; <abbr title="Mean Time To Recover">MTTR</abbr> is higher than active–active.</p>

      <h3 id="backups">Backups</h3>
      <p>Backups are your last line of defense against data loss and corruption. Test restores regularly. Store backups in a separate account/region and encrypt. Track <abbr title="Recovery Point Objective: maximum tolerable data loss">RPO</abbr> and restore time against <abbr title="Recovery Time Objective: maximum tolerable downtime">RTO</abbr>.</p>

      <div class="callout warn">
        <span class="icon">⚖️</span>
        <strong>Trade-off:</strong> Synchronous cross-zone/region replication reduces RPO but increases <abbr title="Time from request to response">latency</abbr> and may reduce availability during partitions. Choose the weakest guarantees that meet user needs.
      </div>
    </section>

    <section class="section" aria-labelledby="dr">
      <h2 id="dr">6.3 Fault-Tolerant Design &amp; Disaster Recovery</h2>
      <p>Fault tolerance combines <em>preventive</em> patterns (timeouts, retries, bulkheads) with <em>restorative</em> strategies (failover and DR).</p>

      <figure>
        <img src="assets/dr-strategies.svg" alt="Table-like diagram: Backup & Restore, Pilot Light, Warm Standby, Multi-Region Active-Active with RTO/RPO arrows" />
        <figcaption>DR options: <em>Backup &amp; restore</em> (cheap, slow), <em>Pilot light</em> (core services always on), <em>Warm standby</em> (scaled-down full stack), <em>Active–active</em> (fast, expensive).</figcaption>
      </figure>

      <div class="grid two">
        <div class="card">
          <h3 class="mt-0">Fault-Tolerant Patterns</h3>
          <ul>
            <li><strong>Timeouts &amp; retries:</strong> Always bound waits; use idempotency keys and exponential backoff.</li>
            <li><strong>Circuit breaker:</strong> Trip on elevated error rates/latency; serve fallbacks while probing recovery.</li>
            <li><strong>Bulkheads:</strong> Dedicated connection/thread pools per dependency.</li>
            <li><strong>Load shedding:</strong> Reject low-priority work when overloaded to preserve core flows.</li>
            <li><strong>Idempotent writes:</strong> Ensure safe retries across failovers.</li>
          </ul>
        </div>
        <div class="card">
          <h3 class="mt-0">DR Planning</h3>
          <ul>
            <li>Define <strong>RPO/RTO</strong> per service; align with business impact tiers.</li>
            <li>Automate failover runbooks; test via <em>game days</em> and <em>chaos drills</em>.</li>
            <li>Use <strong>infrastructure as code</strong> for reproducible recovery.</li>
          </ul>
        </div>
      </div>
    </section>

    <section class="section" aria-labelledby="observability">
      <h2 id="observability">6.4 Monitoring, Logging &amp; Alerts Basics</h2>
      <p><strong>Observability</strong> is your ability to explain system state from external outputs. It rests on three pillars: <strong>metrics</strong> (numeric time series), <strong>logs</strong> (structured records), and <strong>traces</strong> (request timelines). Define <abbr title="Quantitative measures of service health, e.g., latency, error rate">SLIs</abbr> and set <abbr title="Target values for SLIs, e.g., p95 &lt; 300 ms, 99.9% availability">SLOs</abbr> with <em>error budgets</em> that inform release pace.</p>

      <figure>
        <img src="assets/observability-stack.svg" alt="Diagram: exporters → metrics DB (time series), log store, trace collector → dashboards and alerts" />
        <figcaption>Observability stack: instrumentation exports signals; storage backends retain them; dashboards and alerts turn signals into action.</figcaption>
      </figure>

      <div class="grid two">
        <div class="card">
          <h3 class="mt-0">Minimum Dashboard</h3>
          <ul>
            <li>Requests/sec, error rate, and p50/p95/p99 latency (per endpoint).</li>
            <li>Dependency health (DB CPU/IO, cache hit rate, queue depth).</li>
            <li>Saturation (CPU, memory, connection pools).</li>
          </ul>
        </div>
        <div class="card">
          <h3 class="mt-0">Alerting Hygiene</h3>
          <ul>
            <li>Alert on <em>user-impacting</em> symptoms (SLO burn) not just internal noise.</li>
            <li>Use <abbr title="Notifications throttled to avoid alert storms">deduplication and rate limits</abbr> for paging.</li>
            <li>Every page links to a runbook; track <abbr title="Mean Time To Detect">MTTD</abbr> and <abbr title="Mean Time To Resolve">MTTR</abbr>.</li>
          </ul>
        </div>
      </div>
      <div class="callout warn">
        <strong>Pitfall:</strong> Over-alerting trains people to ignore pages. Start with SLO-based burn alerts and a small set of golden signals; add detail dashboards for diagnosis.
      </div>
    </section>

    <section class="section" aria-labelledby="case">
      <h2 id="case">Case Study: Surviving a Cache Cluster Outage (≈200 words)</h2>
      <p>A social app relies on a 3-node Redis cluster for hot feeds. One morning, a networking fault isolates a node; the client library thrashes between nodes, raising tail latency and error rates. The team executes their playbook. <strong>Containment:</strong> Circuit breakers trip for non-critical endpoints; read timeouts cut from 2s → 600ms with jittered retries. <strong>Degradation:</strong> Feeds downgrade to “recent global posts” if cache misses exceed a threshold; CDN continues serving static assets. <strong>Failover:</strong> Traffic shifts away from the impacted shard via consistent-hashing ring update; autoscaling adds two app replicas to absorb extra DB reads. <strong>Recovery:</strong> Once networking stabilizes, the team warms the cache using a background job and gradually restores full features.</p>
      <p>Impact: user-visible errors are limited to a 15-minute window; p95 latency stays within SLO for critical endpoints. A blameless postmortem reveals the need for better connection-pool bulkheads and improves the cache-warm strategy. The incident validates layered defenses—timeouts, bulkheads, graceful degradation, and controlled failover—turning a potential outage into a manageable blip.</p>
    </section>

    <section class="section" aria-labelledby="resources">
      <h2 id="resources">Resources</h2>
      <ul class="resource-list">
        <li class="item">
          <div>
            <a class="external" href="https://sre.google/sre-book/table-of-contents/" target="_blank">Google SRE Book</a>
            <div class="meta">Foundational reading on SLIs/SLOs, error budgets, and incident response.</div>
          </div>
          <span class="badge">SRE</span>
        </li>
        <li class="item">
          <div>
            <a class="external" href="https://docs.aws.amazon.com/wellarchitected/latest/reliability-pillar/welcome.html" target="_blank">AWS Well-Architected — Reliability Pillar</a>
            <div class="meta">Cloud-oriented guidance for redundancy, failover, and disaster recovery patterns.</div>
          </div>
          <span class="badge">Cloud</span>
        </li>
        <li class="item">
          <div>
            <a class="external" href="https://opentelemetry.io/docs/" target="_blank">OpenTelemetry Docs</a>
            <div class="meta">Standardized instrumentation for metrics, logs, and traces.</div>
          </div>
          <span class="badge">Observability</span>
        </li>
      </ul>
    </section>

    <section class="section practice" aria-labelledby="practice">
      <div class="title">Practice <span class="badge">35–60 min</span></div>
      <h2 id="practice" class="mt-1">Hands-on Tasks</h2>
      <ol>
        <li><strong>Write a failure story (10–15 min).</strong> Pick one component from your capstone and describe a realistic failure. List symptoms, blast radius, and a containment plan. <em>Success:</em> Includes timeouts, backoff, and a user-facing fallback.</li>
        <li><strong>RPO/RTO (10–15 min).</strong> Define target RPO/RTO for your data store and map to a DR choice (backup &amp; restore, warm standby, or active–active). <em>Success:</em> Targets have numbers (e.g., RPO ≤ 1 min, RTO ≤ 30 min) and a brief cost rationale.</li>
        <li><strong>Observability MVP (10–15 min).</strong> Propose SLIs/SLOs and a “golden signals” dashboard (RPS, errors, latency percentiles, saturation). <em>Success:</em> SLOs tie to alert thresholds with links to runbooks.</li>
        <li><strong>Chaos drill (optional, 10–15 min).</strong> Simulate a dependency timeout in dev; verify circuit breaker behavior and fallbacks. <em>Success:</em> Error rate contained; logs and metrics confirm expected paths.</li>
      </ol>
    </section>

    <section class="section mastery" aria-labelledby="mastery">
      <div class="title">Mastery Check <span class="badge">Self-assessment</span></div>
      <h2 id="mastery" class="mt-1">Questions (with sample answers)</h2>

      <details>
        <summary>1) Distinguish availability from durability with examples.</summary>
        <div class="pad-2">
          <p><strong>Sample answer:</strong> Availability is “can I access the service now?” Durability is “will my stored data still exist later?” A service can be down (0% availability) yet not lose data (high durability), or be up but lose recent writes after failover (low durability).</p>
        </div>
      </details>

      <details>
        <summary>2) Why are timeouts and retries both necessary—and dangerous?</summary>
        <div class="pad-2">
          <p><strong>Sample answer:</strong> Timeouts prevent threads from hanging; retries heal transient errors. Without backoff and idempotency, retries create traffic storms and duplicate side effects, worsening outages.</p>
        </div>
      </details>

      <details>
        <summary>3) Compare active–active vs. active–passive for a database.</summary>
        <div class="pad-2">
          <p><strong>Sample answer:</strong> Active–active gives fast failover and higher throughput but needs conflict resolution and careful consistency. Active–passive is simpler with leader/follower replication but has higher RTO.</p>
        </div>
      </details>

      <details>
        <summary>4) What does an error budget guide you to do?</summary>
        <div class="pad-2">
          <p><strong>Sample answer:</strong> It balances reliability and velocity: if you’re burning budget too fast, slow down releases/hardening; if budget is healthy, you can safely ship more changes.</p>
        </div>
      </details>

      <details>
        <summary>5) Give a concrete example of graceful degradation.</summary>
        <div class="pad-2">
          <p><strong>Sample answer:</strong> If recommendations are down, serve a cached “popular now” list and hide personalization badges so users can still browse and purchase.</p>
        </div>
      </details>

      <details>
        <summary>6) Define RPO and RTO and map each to a control.</summary>
        <div class="pad-2">
          <p><strong>Sample answer:</strong> RPO is max tolerable data loss → controlled by replication and backup frequency; RTO is max tolerable downtime → controlled by automation and warm capacity.</p>
        </div>
      </details>

      <details>
        <summary>7) What is a bulkhead and where would you use it?</summary>
        <div class="pad-2">
          <p><strong>Sample answer:</strong> An isolation barrier (e.g., dedicated connection/thread pools per dependency) that prevents a failing downstream from exhausting all resources and taking the service down.</p>
        </div>
      </details>
    </section>

    <section class="section" aria-labelledby="recap">
      <h2 id="recap">Recap &amp; Next Steps</h2>
      <p><strong>Recap:</strong> You learned to design for failure: redundancy and failover patterns, DR strategies tuned by RPO/RTO, and an observability baseline grounded in SLIs/SLOs. You practiced writing a failure story, defining budgets, and planning dashboards.</p>
      <p><strong>Next:</strong> In <a href="chapters/ch07.html">Chapter 7</a>, you’ll apply everything in a guided design—choosing a problem (e.g., URL shortener), gathering requirements, and making storage, caching, and scaling choices with explicit trade-offs.</p>
    </section>

    <nav class="next-prev" aria-label="Chapter pager">
      <a rel="prev" href="chapters/ch05.html">Previous: Scalability &amp; Load Handling</a>
      <a rel="next" href="chapters/ch07.html">Next: Guided Practice — Designing a Simple System</a>
    </nav>
  </main>

  <footer class="site-footer">
    <div class="container">
      <p class="mb-0">© 2025 System Design (Beginner). Chapter 6.</p>
    </div>
  </footer>

  <!--
  CHECKLIST (do not remove)
  - [x] /styles/theme.css + /scripts/app.js linked (paths correct for /chapters/)
  - [x] <base href="../"> present & correct
  - [x] Canonical nav verbatim; active link via app.js
  - [x] Pager prev=ch05, next=ch07
  - [x] Sections meet depth: 6.1–6.4 + examples, compare/contrast, analogy, trade-offs
  - [x] Practice (3–4 tasks) with time + success criteria
  - [x] Mastery (6–7 Qs) with sample answers
  - [x] ≥4 figures: reliability-layers.svg, redundancy-patterns.svg, dr-strategies.svg, observability-stack.svg under /assets
  - [x] ≥8 glossary-style terms via <abbr> (availability, durability, MTTR, RTO, RPO, circuit breaker, bulkhead, SLI/SLO, error budget)
  - [x] Recap + Next steps
  -->
</body>
</html>
