<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Ch. 7 — Guided Practice: Designing a Simple System</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="Apply fundamentals by designing a small system end-to-end. Choose a problem, gather requirements, propose a high-level architecture, and justify storage, caching, and scaling decisions.">
  <meta property="og:title" content="Chapter 7 — Guided Practice: Designing a Simple System">
  <meta property="og:description" content="Step-by-step design for a URL shortener, chat app, or tiny twitter. Includes templates, diagrams, trade-offs, and a 15-minute presentation script.">
  <base href="../">
  <link rel="stylesheet" href="styles/theme.css">
  <script src="scripts/app.js" defer></script>
</head>
<body>
  <a class="skip-link" href="#main">Skip to content</a>

  <!-- Canonical Navigation (copy verbatim across all pages) -->
  <nav class="app-nav">
    <div class="container inner">
      <div class="brand">System Design (Beginner)</div>
      <button class="toggle js-nav-toggle" aria-expanded="false" aria-controls="site-menu" aria-label="Toggle menu">☰ Menu</button>
      <div id="site-menu" class="menu" role="navigation" aria-label="Primary">
        <a href="index.html">Home</a>
        <a href="chapters/ch01.html">Chapters</a>
        <a href="chapters/appendix.html">Appendix</a>
        <a href="chapters/glossary.html">Glossary</a>
      </div>
    </div>
  </nav>

  <header class="page-hero" id="top">
    <div class="container">
      <div class="meta">
        <span class="badge badge-primary">Chapter 7</span>
        <span class="badge">Guided Practice</span>
      </div>
      <h1>Guided Practice — Designing a Simple System</h1>
      <p class="abstract">You’ll apply everything so far by designing a small but realistic system—like a <strong>URL shortener</strong>, a <strong>chat app</strong>, or a <strong>tiny twitter</strong>. We’ll walk through requirements, data flow, <abbr title="Application Programming Interface">API</abbr> design, <abbr title="Database schema and data modeling choices">storage</abbr>, <abbr title="Performance improvement via reuse of computation or data">caching</abbr>, and <abbr title="Mechanisms to add capacity and protect availability under traffic">scaling</abbr>. You’ll end with a concise presentation and trade-off discussion.</p>
    </div>
  </header>

  <main id="main" class="container section">
    <section class="section" aria-labelledby="prereqs">
      <h2 id="prereqs">Prerequisites &amp; Objectives</h2>
      <div class="grid two">
        <div class="card">
          <h3 class="mt-0">Prerequisites</h3>
          <ul>
            <li>Chapters 1–6 completed; comfort with basic diagrams.</li>
            <li>Ability to sketch APIs and simple schemas.</li>
          </ul>
        </div>
        <div class="card">
          <h3 class="mt-0">Objectives</h3>
          <ul>
            <li>Gather clear <strong>functional</strong> and <strong>non-functional</strong> requirements.</li>
            <li>Produce a defensible <strong>high-level design</strong> (HLD) with data flow.</li>
            <li>Justify <strong>storage</strong>, <strong>caching</strong>, and <strong>scaling</strong> choices with trade-offs.</li>
            <li>Explain failure modes and <abbr title="Techniques to keep the system operating under faults">fault tolerance</abbr> basics.</li>
            <li>Present the design in &lt;15 minutes with a coherent narrative.</li>
          </ul>
        </div>
      </div>
    </section>
    <section class="section" aria-labelledby="choose">
      <h2 id="choose">7.1 Choose a Sample Problem</h2>
      <p>Select one of the three baseline problems. Each is small enough to finish quickly but rich enough to exercise real design choices.</p>

      <div class="grid three">
        <div class="card">
          <h3 class="mt-0">A) URL Shortener</h3>
          <ul>
            <li><strong>Core:</strong> Map short code → long URL; redirect quickly.</li>
            <li><strong>Constraints:</strong> Read-heavy, tiny payloads, high <abbr title="Requests per second">RPS</abbr>.</li>
            <li><strong>Edge:</strong> Abuse prevention, rate limits, <abbr title="Time To Live">TTL</abbr> for expired links, custom domains.</li>
          </ul>
        </div>
        <div class="card">
          <h3 class="mt-0">B) Chat App</h3>
          <ul>
            <li><strong>Core:</strong> Rooms, users, messages.</li>
            <li><strong>Constraints:</strong> Low-latency pushes, fan-out, backpressure.</li>
            <li><strong>Edge:</strong> Presence, typing indicators, history retention.</li>
          </ul>
        </div>
        <div class="card">
          <h3 class="mt-0">C) Tiny Twitter</h3>
          <ul>
            <li><strong>Core:</strong> Users, tweets, timelines.</li>
            <li><strong>Constraints:</strong> Write fan-out vs. read fan-in, ranking.</li>
            <li><strong>Edge:</strong> Media, search, <abbr title="Content Delivery Network">CDN</abbr>, spam control.</li>
          </ul>
        </div>
      </div>

      <div class="callout info">
        <strong>Tip:</strong> Pick URL shortener for your first pass—great for practicing <em>idempotency</em>, <em>cache keys</em>, and <em>hot key</em> mitigation.
      </div>
    </section>

    <section class="section" aria-labelledby="requirements">
      <h2 id="requirements">7.2 Requirements Gathering</h2>
      <p>Good designs start with <strong>explicit requirements</strong>. Capture both functional needs and non-functional targets.</p>

      <div class="grid two">
        <div class="card">
          <h3 class="mt-0">Template</h3>
          <ul>
            <li><strong>Functional:</strong> What must the system do? (create short link, redirect, analytics)</li>
            <li><strong>Non-functional:</strong> p95 <abbr title="Time from request to response">latency</abbr>, availability, cost constraints, privacy.</li>
            <li><strong>Scale assumptions:</strong> DAU, RPS, data growth, traffic patterns.</li>
            <li><strong>Back-of-envelope:</strong> bytes/request, storage/day, cache sizes.</li>
          </ul>
        </div>
        <div class="card">
          <h3 class="mt-0">Example (URL Shortener)</h3>
          <ul>
            <li>Redirect p95 &lt; 30 ms (edge), p99 &lt; 120 ms (global).</li>
            <li>Availability: 99.9%. Durability: no loss of created links.</li>
            <li>Scale: 3k create/s peak, 150k redirect/s peak; 100 B payloads.</li>
            <li>Analytics: daily click counts, country breakdown (eventual OK).</li>
          </ul>
        </div>
      </div>

      <div class="callout warn">
        <span class="icon">⚠️</span>
        <strong>Pitfall:</strong> Vague “handle millions of users” claims. Put numbers (even rough) on RPS, latency, and growth to drive concrete choices (indexes, TTLs, shard keys).
      </div>
    </section>

    <section class="section" aria-labelledby="hld">
      <h2 id="hld">7.3 High-Level Design (Components &amp; Data Flow)</h2>
      <p>This section walks through a URL shortener design. Adapt the pattern to the other problems as practice.</p>
      <h3 id="api">API &amp; Contracts</h3>
      <ul>
        <li><code>POST /links</code> → <code>{ longUrl, customAlias? }</code> → <code>{ code, shortUrl }</code> (201). <em>Idempotency-Key</em> header to avoid duplicates.</li>
        <li><code>GET /{code}</code> → 301 redirect to long URL. <em>Cache-Control</em> at edge (short TTL) + server cache.</li>
        <li><code>POST /links/{code}/expire</code> (auth) → mark expired (soft delete); purge caches.</li>
      </ul>

      <h3 id="data-model">Data Model</h3>
      <div class="grid two">
        <div class="card">
          <p><strong>SQL option:</strong> Table <code>links(code PK, long_url, created_at, owner_id, expires_at, flags, hash)</code>. Index on <code>hash</code> (first 8–12 bytes of normalized URL) + <code>owner_id</code>. Transactions guarantee uniqueness and durability. </p>
          <p><strong>NoSQL option:</strong> <em>Key-value</em> with <code>code → long_url</code>, secondary index simulated via <code>hash → code</code> mapping. Great for massive read scale and tiny values.</p>
        </div>
        <div class="card">
          <p><strong>Code generation:</strong> Base62 (0–9, a–z, A–Z) from an <em>auto-increment id</em> or a <em>random id</em>.</p>
          <ul>
            <li><em>Auto-increment:</em> Simple, sequential; risk of guessable URLs; sharding needs id allocation.</li>
            <li><em>Random (128-bit truncated):</em> Collision risk negligible with checking; good for security by obscurity; supports multi-writer without coordination.</li>
          </ul>
        </div>
      </div>

      <div class="callout warn">
        <strong>Trade-off:</strong> Random ids ease horizontal scale and reduce enumeration risk, but complicate analytics order and human debugging. Sequential ids simplify storage locality but invite scraping and require careful shard-id allocation.
      </div>

      <h3 id="read-path">Read Path (Redirect)</h3>
      <ol>
        <li><strong>Client → Edge:</strong> CDN terminates TLS and caches 301 for hot codes (short TTL, e.g., 60–300 s).</li>
        <li><strong>Edge → App:</strong> App checks <strong>server cache</strong> (Redis) for <code>code</code>. On miss, read from DB and set cache with TTL + jitter.</li>
        <li><strong>Response:</strong> 301 redirect with <code>Location</code> header. Optionally enqueue an <em>analytics event</em> to a queue (no request delay).</li>
      </ol>

      <h3 id="write-path">Write Path (Create)</h3>
      <ol>
        <li>Validate URL; normalize (lowercase host, strip tracking params if policy allows).</li>
        <li>Compute <code>hash</code> of <code>long_url</code> to detect dupes; enforce owner-based quotas.</li>
        <li>Generate code (random or base62 of id) and insert record <em>idempotently</em> (unique constraints or conditional put).</li>
        <li>Warm cache for the new code; purge any previous negative-cache entries.</li>
      </ol>

      <h3 id="capacity">Capacity &amp; Scaling</h3>
      <ul>
        <li><strong>RPS:</strong> 150k redirect/s peak → ~85% served at edge/CDN; origin handles ~22.5k/s; cache hit target &gt; 90% at app, DB reads &lt; 2.5k/s.</li>
        <li><strong>Storage:</strong> 100 B per link × 1B links ≈ 100 GB base (excluding indexes), feasible on sharded KV or partitioned SQL.</li>
        <li><strong>Hot keys:</strong> Viral links can dominate. Use <em>request coalescing</em>, <em>soft TTL</em>, and <em>per-key rate limits</em> to protect DB.</li>
      </ul>

      <h3 id="reliability">Reliability &amp; Safety</h3>
      <ul>
        <li><strong>Availability:</strong> Active–active app across zones; health checks; <abbr title="Automatic removal of slow or failing nodes from rotation">outlier detection</abbr> at the load balancer.</li>
        <li><strong>Durability:</strong> DB with leader–follower replication; backups and periodic restore tests; <abbr title="Recovery Point Objective">RPO</abbr> ≤ 1 min.</li>
        <li><strong>Abuse controls:</strong> <abbr title="Limits to protect the service from abuse and bugs">rate limiting</abbr>, blocklists, malware scanning on submit, signed user sessions.</li>
      </ul>

      <h3 id="alternatives">Alternatives Table</h3>
      <table>
        <thead><tr><th>Component</th><th>Choice</th><th>Alternative</th><th>Why/When</th></tr></thead>
        <tbody>
          <tr><td>API Style</td><td>REST</td><td>gRPC</td><td>REST is browser/CDN-native; gRPC for internal control plane.</td></tr>
          <tr><td>Storage</td><td>KV (Redis/Cassandra)</td><td>Relational (Postgres)</td><td>KV for huge read scale; SQL for strong constraints and admin UI ease.</td></tr>
          <tr><td>Code Gen</td><td>Random 8–10 chars</td><td>Base62(id)</td><td>Random reduces enumeration; Base62 enables monotonically growing ids.</td></tr>
          <tr><td>Analytics</td><td>Async events</td><td>Sync counters</td><td>Async avoids adding latency on redirect.</td></tr>
        </tbody>
      </table>
    </section>

    <section class="section" aria-labelledby="detailing">
      <h2 id="detailing">7.4 Detailing Storage, Caching, and Scaling Choices</h2>
      <p>Making decisions explicit helps you defend your design and adapt under new constraints.</p>

      <div class="grid two">
        <div class="card">
          <h3 class="mt-0">Storage Decision</h3>
          <p><strong>Pick:</strong> Key-Value store for <code>code → url</code>; relational sidecar for admin &amp; abuse reports.</p>
          <ul>
            <li><strong>Pros:</strong> KV is fast, simple, horizontally scalable; relational sidecar supports queries/joins for admin.</li>
            <li><strong>Cons:</strong> Two datastores to operate; need consistency across them (event or CDC).</li>
          </ul>
        </div>
        <div class="card">
          <h3 class="mt-0">Caching Strategy</h3>
          <ul>
            <li><strong>Edge:</strong> CDN caches 301 by code for 1–5 minutes; purge on expire.</li>
            <li><strong>App:</strong> Redis cache-aside with 60–120 s TTL + jitter; negative caching for unknown codes for 30 s.</li>
            <li><strong>Stampedes:</strong> Coalesce requests; soft TTL to serve slightly stale during refresh.</li>
          </ul>
        </div>
      </div>

      <div class="grid two">
        <div class="card">
          <h3 class="mt-0">Scaling Plan</h3>
          <ul>
            <li><strong>Stateless app</strong> behind least-connections LB; autoscale by p95 latency and queue depth.</li>
            <li><strong>Sharding:</strong> Consistent hashing of <code>code</code>; virtual nodes to smooth distribution.</li>
            <li><strong>Backpressure:</strong> Rate-limit creates; reject at edge with informative 429 and retry-after.</li>
          </ul>
        </div>
        <div class="card">
          <h3 class="mt-0">Observability</h3>
          <ul>
            <li><strong>SLIs:</strong> redirect p95, error rate, cache hit ratio, DB latency.</li>
            <li><strong>Traces:</strong> Correlate cache miss → DB read → response; watch tail latency.</li>
            <li><strong>Alerts:</strong> SLO burn, cache hit ratio &lt; target, DB CPU &gt; 80% sustained.</li>
          </ul>
        </div>
      </div>
      <div class="callout info">
        <strong>Analogy:</strong> Think of your design like packing for a trip with baggage limits: you can’t bring everything. Prioritize items (features/guarantees) that match the itinerary (use cases) and weather (traffic patterns).
      </div>
    </section>

    <section class="section" aria-labelledby="case-study">
      <h2 id="case-study">Case Study: Presenting in 15 Minutes (≈200 words)</h2>
      <p><strong>Minute 0–2 — Problem &amp; Requirements.</strong> “We’re designing a URL shortener. Functional: create and redirect. Non-functional: p95 redirect &lt; 30 ms at edge, 99.9% availability, abuse controls. Peak: 150k redirect/s.”</p>
      <p><strong>Minute 2–5 — API &amp; Data.</strong> “REST endpoints: <code>POST /links</code>, <code>GET /{code}</code>, idempotency via header. Data: KV mapping <code>code → url</code>, relational sidecar for admin.”</p>
      <p><strong>Minute 5–9 — Architecture &amp; Scale.</strong> “Edge/CDN caches 301s. Stateless app behind LB; Redis for hot codes with 60–120 s TTL + jitter. DB replication; consistent-hash sharding when partitions grow. Capacity math shows origin needs ~22.5k RPS with 85% edge hit; Redis hit &gt; 90%.”</p>
      <p><strong>Minute 9–12 — Reliability &amp; Failure.</strong> “Timeouts, retries with backoff; circuit breakers. DR: replicas across zones, backups with RPO ≤ 1 min. Degradation: if DB degraded, serve a helpful error or cached responses.”</p>
      <p><strong>Minute 12–15 — Trade-offs &amp; Q&amp;A.</strong> “Chose random codes for scale/security; accepted slightly harder debugging. Edge caching reduces origin cost but risks brief staleness—mitigated via short TTL + purges. Analytics is async for latency. Open risks: global rate limiting and abuse detection—future work.”</p>
    </section>

    <section class="section" aria-labelledby="resources">
      <h2 id="resources">Resources</h2>
      <ul class="resource-list">
        <li class="item">
          <div>
            <a class="external" href="https://github.com/donnemartin/system-design-primer#system-design-topics-start-here" target="_blank">System Design Primer — Case Studies</a>
            <div class="meta">Practice problems and reference designs to compare against your solution.</div>
          </div>
          <span class="badge">Practice</span>
        </li>
        <li class="item">
          <div>
            <a class="external" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/301" target="_blank">MDN — 301 Moved Permanently</a>
            <div class="meta">Redirect semantics for the shortener’s hot path.</div>
          </div>
          <span class="badge">HTTP</span>
        </li>
        <li class="item">
          <div>
            <a class="external" href="https://redis.io/docs/latest/develop/use/patterns/caching/" target="_blank">Redis — Caching Patterns</a>
            <div class="meta">Cache-aside, write-through, eviction, and stampede control.</div>
          </div>
          <span class="badge">Caching</span>
        </li>
      </ul>
    </section>

    <section class="section practice" aria-labelledby="practice">
      <div class="title">Practice <span class="badge">60–120 min</span></div>
      <h2 id="practice" class="mt-1">Hands-on Tasks</h2>
      <ol>
        <li><strong>Pick &amp; scope (10–15 min).</strong> Choose URL shortener, chat, or tiny twitter. Write functional and non-functional requirements with numbers. <em>Success:</em> Includes latency targets, RPS estimates, and data growth.</li>
        <li><strong>APIs &amp; data (15–25 min).</strong> Define 3–5 endpoints and a minimal schema. <em>Success:</em> At least one idempotent write; keys/indexes align with top queries.</li>
        <li><strong>HLD diagram (15–25 min).</strong> Draw boxes and arrows for client, edge, LB, app, cache, DB, and any queues. <em>Success:</em> Each arrow has protocol and timeout noted.</li>
        <li><strong>Trade-offs &amp; risks (10–20 min).</strong> Write 4–6 explicit trade-offs and 3 risks with mitigations. <em>Success:</em> Each trade-off names what you gained and what you gave up.</li>
        <li><strong>Lightning deck (10–20 min).</strong> Create 4–6 slides to present in 15 minutes. <em>Success:</em> Slides map 1:1 to the presentation outline above.</li>
      </ol>
    </section>

    <section class="section mastery" aria-labelledby="mastery">
      <div class="title">Mastery Check <span class="badge">Self-assessment</span></div>
      <h2 id="mastery" class="mt-1">Questions (with sample answers)</h2>

      <details>
        <summary>1) Why is a URL shortener typically read-heavy, and how does that shape the design?</summary>
        <div class="pad-2">
          <p><strong>Sample answer:</strong> Redirects far outnumber creates; most traffic is <code>GET /{code}</code>. This favors CDN + cache for latency and DB protection, with asynchronous analytics to avoid slowing the hot path.</p>
        </div>
      </details>

      <details>
        <summary>2) Give an idempotency design for <code>POST /links</code>.</summary>
        <div class="pad-2">
          <p><strong>Sample answer:</strong> Clients send an <em>Idempotency-Key</em> header; the server stores the key with the resulting code for a retention window and returns the same response on retries.</p>
        </div>
      </details>

      <details>
        <summary>3) Choose between SQL and KV for the code→URL mapping and justify.</summary>
        <div class="pad-2">
          <p><strong>Sample answer:</strong> KV because lookups are by primary key with tiny values; we don’t need joins. SQL is still useful as an admin/analytics sidecar.</p>
        </div>
      </details>

      <details>
        <summary>4) Describe two failure modes and your mitigations.</summary>
        <div class="pad-2">
          <p><strong>Sample answer:</strong> Cache cluster outage → serve from DB with stricter rate limits, degrade analytics; CDN purge failure → shorten TTLs temporarily and increase app cache reliance.</p>
        </div>
      </details>

      <details>
        <summary>5) What’s your sharding key and why?</summary>
        <div class="pad-2">
          <p><strong>Sample answer:</strong> The short <code>code</code> (or its hash) because traffic and storage are naturally distributed by code; consistent hashing limits remap during scaling.</p>
        </div>
      </details>

      <details>
        <summary>6) How do you prevent hot keys from melting the origin?</summary>
        <div class="pad-2">
          <p><strong>Sample answer:</strong> Edge caching, request coalescing, per-key rate limits, and soft TTL to serve stale while refreshing; optionally pre-warm hot codes at edge during campaigns.</p>
        </div>
      </details>

      <details>
        <summary>7) Explain a privacy consideration for analytics.</summary>
        <div class="pad-2">
          <p><strong>Sample answer:</strong> Avoid logging full IPs/URLs in plaintext; aggregate counts and use country-level geodata; implement data retention policies and access controls.</p>
        </div>
      </details>
    </section>

    <section class="section" aria-labelledby="recap">
      <h2 id="recap">Recap &amp; Next Steps</h2>
      <p><strong>Recap:</strong> You picked a problem, wrote measurable requirements, and produced an HLD with APIs, data model, and capacity considerations. You chose storage, caching, and scaling strategies with explicit trade-offs and planned for failures and observability. You also prepared a short presentation.</p>
      <p><strong>Next:</strong> In <a href="chapters/ch08.html">Chapter 8</a>, you’ll consolidate lessons, review common pitfalls, and map your transition to the intermediate level.</p>
    </section>

    <nav class="next-prev" aria-label="Chapter pager">
      <a rel="prev" href="chapters/ch06.html">Previous: Reliability &amp; Fault Tolerance</a>
      <a rel="next" href="chapters/ch08.html">Next: Pitfalls, Review &amp; Next Steps</a>
    </nav>
  </main>

  <footer class="site-footer">
    <div class="container">
      <p class="mb-0">© 2025 System Design (Beginner). Chapter 7.</p>
    </div>
  </footer>

  <!--
  CHECKLIST (do not remove)
  - [x] /styles/theme.css + /scripts/app.js linked (paths correct for /chapters/)
  - [x] <base href="../"> present & correct
  - [x] Canonical nav verbatim; active link via app.js
  - [x] Pager prev=ch06, next=ch08
  - [x] Sections meet depth: 7.1–7.4 + examples, comparison, analogy, trade-offs
  - [x] Practice (5 tasks) with time + success criteria
  - [x] Mastery (6–7 Qs) with sample answers
  - [x] ≥8 glossary-style terms via <abbr> (API, latency, RPS, TTL, idempotency, CDN, rate limiting, RPO)
  - [x] Recap + Next steps
  -->
</body>
</html>
