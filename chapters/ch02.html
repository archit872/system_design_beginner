<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Ch. 2 — Core Concepts: Clients, Servers & Communication</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="Learn the client–server model, request/response, REST vs. RPC, and protocols including HTTP, WebSockets, and gRPC. Includes examples and a tiny chat walkthrough.">
  <meta property="og:title" content="Chapter 2 — Clients, Servers & Communication">
  <meta property="og:description" content="Request/response cycles, synchronous vs. asynchronous comms, REST vs. RPC, HTTP/WebSockets/gRPC basics, and a small chat example.">
  <base href="../">
  <link rel="stylesheet" href="styles/theme.css">
  <script src="scripts/app.js" defer></script>
</head>
<body>
  <a class="skip-link" href="#main">Skip to content</a>

  <!-- Canonical Navigation (copy verbatim across all pages) -->
  <nav class="app-nav">
    <div class="container inner">
      <div class="brand">System Design (Beginner)</div>
      <button class="toggle js-nav-toggle" aria-expanded="false" aria-controls="site-menu" aria-label="Toggle menu">☰ Menu</button>
      <div id="site-menu" class="menu" role="navigation" aria-label="Primary">
        <a href="index.html">Home</a>
        <a href="chapters/ch01.html">Chapters</a>
        <a href="chapters/appendix.html">Appendix</a>
        <a href="chapters/glossary.html">Glossary</a>
      </div>
    </div>
  </nav>

  <header class="page-hero" id="top">
    <div class="container">
      <div class="meta">
        <span class="badge badge-primary">Chapter 2</span>
        <span class="badge">Core Concepts</span>
      </div>
      <h1>Clients, Servers &amp; Communication</h1>
      <p class="abstract">This chapter explains the <abbr title="Programs that initiate requests (e.g., browsers, mobile apps)">client</abbr>–<abbr title="Programs that accept and handle requests over a network">server</abbr> model, how requests and responses move across the network, and when to choose <strong>REST</strong> vs. <strong>RPC</strong>. You’ll compare synchronous and asynchronous patterns and explore <abbr title="Hypertext Transfer Protocol, the web’s primary application protocol">HTTP</abbr>, <abbr title="A bidirectional, full-duplex protocol often used for real-time features">WebSockets</abbr>, and <abbr title="A high-performance RPC framework using HTTP/2 with Protocol Buffers">gRPC</abbr>. We finish with a tiny chat example that you can prototype locally.</p>
    </div>
  </header>

  <main id="main" class="container section">
    <section class="section" aria-labelledby="prereqs">
      <h2 id="prereqs">Prerequisites &amp; Learning Objectives</h2>
      <div class="grid two">
        <div class="card">
          <h3 class="mt-0">Prerequisites</h3>
          <ul>
            <li>Basic command of one programming language.</li>
            <li>Basic networking knowledge (IP/ports, very high-level).</li>
          </ul>
        </div>
        <div class="card">
          <h3 class="mt-0">Objectives</h3>
          <ul>
            <li>Explain the client–server model and diagram a request/response cycle.</li>
            <li>Differentiate synchronous vs. asynchronous communication and when to use each.</li>
            <li>Compare <strong>REST</strong> and <strong>RPC</strong> at the API design level.</li>
            <li>Understand HTTP basics, plus where WebSockets and gRPC fit.</li>
            <li>Build and reason about a minimal client–server chat interaction.</li>
          </ul>
        </div>
      </div>
    </section>

    <figure>
      <img src="assets/client-server-seq.svg" alt="Sequence diagram: Client → DNS → CDN → Load Balancer → API → Service → Cache/DB → back to Client" />
      <figcaption>Request lifecycle: a browser (client) resolves DNS, fetches static assets via CDN, and sends API calls through a load balancer to a stateless service that reads from a cache and database.</figcaption>
    </figure>

    <section class="section" aria-labelledby="model">
      <h2 id="model">2.1 Client–Server Model Explained</h2>
      <p>The client–server model divides responsibility: the <strong>client</strong> initiates a request and renders results; the <strong>server</strong> performs work and returns a response. This separation enables scaling and specialization: clients optimize for user experience, servers optimize for correctness and throughput. A single logical “server” is usually a <em>cluster</em> of replicas behind a <abbr title="Component that distributes traffic across replicas">load balancer</abbr>.</p>
      <p><strong>Analogy:</strong> Think of a restaurant. The client is the diner placing an order; the server is the kitchen preparing dishes. The wait staff (protocols) carries standardized tickets (requests) and plates (responses). A busy restaurant adds more cooks (horizontal scaling) and a maître d’ (load balancer) to seat guests evenly.</p>
      <p><strong>Example 1 (Read path):</strong> A mobile client fetches a user profile. It sends <code>GET /users/42</code>. The service reads from a cache; on a miss, it queries the database and populates the cache with a TTL. The response includes HTTP status <code>200</code> and JSON.</p>
      <p><strong>Example 2 (Write path):</strong> The client updates a profile with <code>PUT /users/42</code>. The server validates, writes to the database, and invalidates the cache entry. Because writes are rarer than reads, caching focuses on read-heavy endpoints to reduce <abbr title="Time from request to response">latency</abbr> and increase <abbr title="Units of work per second">throughput</abbr>.</p>
      <div class="callout warn"><strong>Pitfall:</strong> Treating the client as “dumb.” Offloading all validation and state to the server increases chattiness. Lightweight client-side validation and caching (ETags, If-None-Match) can cut round-trips and improve perceived performance.</div>
    </section>

    <section class="section" aria-labelledby="sync-async">
      <h2 id="sync-async">2.2 Synchronous vs. Asynchronous Communication</h2>
      <p><strong>Synchronous</strong> communication means the caller waits for the result (e.g., an HTTP request). It keeps flow simple and is ideal for low-latency actions that a user must immediately see (login, read profile). The downside is tight coupling to dependency latency and availability.</p>
      <p><strong>Asynchronous</strong> communication decouples work using queues or streams. The client or upstream service enqueues a message and proceeds; workers process messages in the background. This improves resilience and smooths bursts but adds <abbr title="Delay between request acceptance and completion">end-to-end latency</abbr> and <abbr title="The state where requests can be accepted but not yet fully applied">eventual consistency</abbr> concerns.</p>
      <div class="grid two">
        <div class="card">
          <h3 class="mt-0">Compare &amp; Contrast</h3>
          <table>
            <thead><tr><th>Aspect</th><th>Sync</th><th>Async</th></tr></thead>
            <tbody>
              <tr><td>Flow</td><td>Call–wait–respond</td><td>Enqueue–return; process later</td></tr>
              <tr><td>Latency</td><td>Low if dependencies are fast</td><td>Higher; amortized via batching</td></tr>
              <tr><td>Failure isolation</td><td>Poor (cascades)</td><td>Better (buffers, retries)</td></tr>
              <tr><td>Complexity</td><td>Simpler code</td><td>More infra (queues, DLQs)</td></tr>
            </tbody>
          </table>
        </div>
        <div class="card">
          <h3 class="mt-0">Pattern</h3>
          <p><strong>Async confirmation for long work.</strong> Accept a request synchronously (<code>202 Accepted</code> + job id). Process in background; the client polls <code>GET /jobs/{id}</code> or subscribes via WebSocket for completion.</p>
        </div>
      </div>
    </section>

    <section class="section" aria-labelledby="apis">
      <h2 id="apis">2.3 APIs: REST vs. RPC Overview</h2>
      <p><strong>REST</strong> models resources (nouns) with standard verbs (<code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code>). It’s web-native, cache-friendly, and human-readable (JSON). Versioning often uses URLs (<code>/v1/</code>) or headers. REST shines for public APIs, CRUD, and when HTTP caching matters.</p>
      <p><strong>RPC</strong> (Remote Procedure Call) models operations (verbs) like <code>CreateUser</code> or <code>SendMessage</code>, often using an Interface Definition Language (IDL) and code generation. <strong>gRPC</strong>—a popular RPC framework—uses HTTP/2 multiplexing and Protobuf for compact, strongly typed messages. RPC shines for internal service-to-service calls that value schema contracts and performance.</p>
      <figure>
        <img src="assets/protocols-spectrum.svg" alt="Spectrum diagram positioning REST (resource-oriented), WebSockets (bidirectional), and gRPC (operation-oriented, typed) across use cases" />
        <figcaption>Choosing a style: REST favors resource modeling and caching; WebSockets favor real-time bidirectionality; gRPC favors binary efficiency and typed contracts.</figcaption>
      </figure>
      <div class="callout info"><strong>Rule of thumb:</strong> Prefer REST for external/public APIs; prefer RPC/gRPC for high-throughput internal service calls; prefer WebSockets for push-heavy, real-time features (chat, presence, live counters).</div>
      <div class="callout warn"><strong>Trade-off:</strong> gRPC brings performance and strong typing but adds complexity for browsers (gRPC-Web, proxies). REST is simpler and universally supported but may be verbose and slower under heavy internal traffic.</div>
    </section>

    <section class="section" aria-labelledby="protocols">
      <h2 id="protocols">2.4 Communication Protocols (HTTP, WebSockets, gRPC basics)</h2>
      <h3 id="http">HTTP</h3>
      <p>HTTP is the application protocol of the web. With HTTP/1.1, connections are persistent but requests are serialized; HTTP/2 introduces multiplexing over one connection; HTTP/3 (over QUIC) further improves head-of-line blocking at the transport layer. For system design, focus on methods, status codes, headers, caching (Cache-Control, ETag), and TLS for security.</p>
      <h3 id="websockets">WebSockets</h3>
      <p>WebSockets upgrade an HTTP connection to a full-duplex channel so client and server can push data to each other. This is useful for chat, collaborative editing, and live dashboards. You’ll still need authentication, <abbr title="Mechanisms that protect a server from too many concurrent connections or messages">rate limits</abbr>, and backpressure.</p>
      <h3 id="grpc">gRPC</h3>
      <p>gRPC defines services and messages in <code>.proto</code> files, compiles client/server stubs, and communicates over HTTP/2 by default. It supports unary calls, client/server streaming, and bidirectional streaming. The benefits are compact payloads and consistent contracts; the cost is operational complexity and limited native browser support (mitigated with gateways or gRPC-Web).</p>
      <div class="grid two mt-2">
        <div class="card">
          <h3 class="mt-0">When to use which?</h3>
          <ul>
            <li><strong>REST</strong>: public APIs, CRUD, caching via CDN, browser-native.</li>
            <li><strong>WebSockets</strong>: low-latency push (chat, notifications, live sports), collaborative cursors.</li>
            <li><strong>gRPC</strong>: internal microservices, polyglot backends, high RPS, strict schemas.</li>
          </ul>
        </div>
        <div class="card">
          <h3 class="mt-0">Security quick hits</h3>
          <ul>
            <li>Use TLS everywhere; prefer short-lived tokens (JWT/OAuth) with rotation.</li>
            <li>Validate inputs server-side; implement quotas and <abbr title="Limits to protect availability under abuse or bugs">rate limiting</abbr>.</li>
            <li>Log request ids/correlation ids for traceability; avoid sensitive data in logs.</li>
          </ul>
        </div>
      </div>
    </section>

    <section class="section" aria-labelledby="example-chat">
      <h2 id="example-chat">2.5 Example: Building a Simple Client–Server Chat</h2>
      <p>This mini-walkthrough shows two alternatives for a tiny chat: <strong>long polling over REST</strong> and <strong>WebSockets</strong>. Both illustrate key design moves: defining contracts, handling bursty traffic, and ensuring <abbr title="Operation semantics where repeats have no additional effect">idempotency</abbr> on retries.</p>

      <h3 id="long-polling">Option A — REST with Long Polling</h3>
      <ol>
        <li><strong>Send message (sync):</strong> Client <code>POST /rooms/{id}/messages</code> with JSON <code>{id, sender, text, ts}</code>. Server validates, persists, and returns <code>201</code>. The <code>id</code> (UUID) makes the operation idempotent.</li>
        <li><strong>Receive messages (async-ish):</strong> Client <code>GET /rooms/{id}/poll?since=ts</code>. Server blocks up to 25s waiting for new messages (or returns sooner). Client repeats, advancing <code>since</code>.</li>
        <li><strong>Scale:</strong> Horizontally scale API servers; use a cache (e.g., Redis) to fan-out new-message notifications so pollers don’t hammer the DB.</li>
      </ol>

      <h3 id="websocket">Option B — WebSockets</h3>
      <ol>
        <li><strong>Connect:</strong> Client opens <code>wss://api.example.com/chat</code> and authenticates.</li>
        <li><strong>Send/receive:</strong> Both sides push messages on the same connection; the server broadcasts to room subscribers.</li>
        <li><strong>Scale:</strong> Use a message bus (e.g., pub/sub) to distribute messages across WebSocket nodes; implement backpressure and per-connection quotas.</li>
      </ol>

      <div class="grid two">
        <figure>
          <img src="assets/chat-sequence.svg" alt="Sequence diagram comparing long-polling flow vs. WebSocket flow for a chat room" />
          <figcaption>Two roads to “chat”: long polling is simpler and CDN-friendly; WebSockets provide lower latency and push.</figcaption>
        </figure>
        <div class="card">
          <h3 class="mt-0">Trade-off Spotlight</h3>
          <p><strong>Long polling</strong> is simpler, uses standard HTTP infrastructure, and plays well with CDNs, but incurs request overhead. <strong>WebSockets</strong> cut latency and bandwidth for active rooms but require connection-oriented scaling and careful resource limits.</p>
        </div>
      </div>
    </section>

    <section class="section" aria-labelledby="resources">
      <h2 id="resources">Resources</h2>
      <ul class="resource-list">
        <li class="item">
          <div>
            <a class="external" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview" target="_blank">MDN — HTTP Overview</a>
            <div class="meta">Concise reference for methods, status codes, headers, and caching.</div>
          </div>
          <span class="badge">Reference</span>
        </li>
        <li class="item">
          <div>
            <a class="external" href="https://grpc.io/docs/what-is-grpc/introduction/" target="_blank">gRPC — Official Introduction</a>
            <div class="meta">RPC semantics, streaming types, and ecosystem.</div>
          </div>
          <span class="badge">RPC</span>
        </li>
        <li class="item">
          <div>
            <a class="external" href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API" target="_blank">MDN — WebSockets API</a>
            <div class="meta">Browser APIs, lifecycle, and best practices.</div>
          </div>
          <span class="badge">Real-time</span>
        </li>
        <li class="item">
          <div>
            <a class="external" href="https://cloudflare.com/learning/cdn/what-is-a-cdn/" target="_blank">Cloudflare Learning — CDN Basics</a>
            <div class="meta">How CDNs accelerate delivery and reduce origin load.</div>
          </div>
          <span class="badge">Performance</span>
        </li>
      </ul>
    </section>

    <section class="section practice" aria-labelledby="practice">
      <div class="title">Practice <span class="badge">30–45 min</span></div>
      <h2 id="practice" class="mt-1">Hands-on Tasks</h2>
      <ol>
        <li><strong>Hello server.</strong> Implement a minimal HTTP server (any language) that returns <code>{"ok":true}</code> for <code>GET /health</code>. <em>Success:</em> Responds under 50 ms locally; returns status <code>200</code> with JSON.</li>
        <li><strong>Echo chat (long polling).</strong> Add endpoints <code>POST /messages</code> and <code>GET /messages/poll?since=...</code>. Use an in-memory queue and timestamps. <em>Success:</em> Two terminal clients can exchange messages.</li>
        <li><strong>WebSocket upgrade.</strong> Replace long polling with a WebSocket endpoint and broadcast incoming messages to all subscribers. <em>Success:</em> A message appears to all connected clients within ~100 ms locally.</li>
        <li><strong>Idempotent send.</strong> Add a client-generated <code>messageId</code> and reject duplicates. <em>Success:</em> Retried sends don’t duplicate messages.</li>
      </ol>
    </section>

    <section class="section mastery" aria-labelledby="mastery">
      <div class="title">Mastery Check <span class="badge">Self-assessment</span></div>
      <h2 id="mastery" class="mt-1">Questions (with sample answers)</h2>

      <details>
        <summary>1) When would you choose synchronous over asynchronous communication?</summary>
        <div class="pad-2">
          <p><strong>Sample answer:</strong> Choose sync when the user needs an immediate result and the work is fast (auth, lookups). Choose async when work is slow or spiky (image processing), or when you must isolate failures via queues and retries.</p>
        </div>
      </details>

      <details>
        <summary>2) Give one pro and one con of REST vs. gRPC for internal microservices.</summary>
        <div class="pad-2">
          <p><strong>Sample answer:</strong> REST: simple and debuggable but verbose and slower at high RPS. gRPC: compact and strongly typed, supports streaming, but adds operational complexity and browser limitations.</p>
        </div>
      </details>

      <details>
        <summary>3) Why do WebSockets require careful backpressure controls?</summary>
        <div class="pad-2">
          <p><strong>Sample answer:</strong> A single client can send faster than the server or network can handle, exhausting buffers and memory. Backpressure and quotas prevent one connection from destabilizing the node.</p>
        </div>
      </details>

      <details>
        <summary>4) Explain idempotency in the context of message sending.</summary>
        <div class="pad-2">
          <p><strong>Sample answer:</strong> The client attaches a unique <code>messageId</code>. The server stores processed ids and drops duplicates so retries don’t create multiple messages.</p>
        </div>
      </details>

      <details>
        <summary>5) What changes when moving from HTTP/1.1 to HTTP/2 or HTTP/3 for API calls?</summary>
        <div class="pad-2">
          <p><strong>Sample answer:</strong> HTTP/2 multiplexes parallel requests on one connection, reducing head-of-line blocking at the application layer. HTTP/3 builds on QUIC to further reduce transport-layer head-of-line issues and improve connection migration; the API semantics are similar but performance and reliability improve.</p>
        </div>
      </details>

      <details>
        <summary>6) Describe a failure mode unique to long polling and one unique to WebSockets.</summary>
        <div class="pad-2">
          <p><strong>Sample answer:</strong> Long polling can create thundering herds when many clients reconnect on a timer. WebSockets can leak server resources if connections aren’t closed on network partitions (half-open sockets).</p>
        </div>
      </details>
    </section>

    <section class="section" aria-labelledby="recap">
      <h2 id="recap">Recap &amp; Next Steps</h2>
      <p><strong>Recap:</strong> You learned how clients and servers coordinate over protocols, how to weigh synchronous vs. asynchronous patterns, and how REST, WebSockets, and gRPC fit different needs. You practiced by sketching and prototyping a chat with two communication styles, and you considered reliability and idempotency concerns.</p>
      <p><strong>Next:</strong> In <a href="chapters/ch03.html">Chapter 3</a>, we go deep on storage: when to pick SQL vs. NoSQL, how indexes shape performance, and how replication affects consistency.</p>
    </section>

    <nav class="next-prev" aria-label="Chapter pager">
      <a rel="prev" href="chapters/ch01.html">Previous: Orientation — What is System Design?</a>
      <a rel="next" href="chapters/ch03.html">Next: Storage &amp; Databases Fundamentals</a>
    </nav>
  </main>

  <footer class="site-footer">
    <div class="container">
      <p class="mb-0">© 2025 System Design (Beginner). Chapter 2.</p>
    </div>
  </footer>

  <!--
  CHECKLIST (do not remove)
  - [x] /styles/theme.css + /scripts/app.js linked (paths correct for /chapters/)
  - [x] <base href="../"> present & correct
  - [x] Canonical nav verbatim; active link handled by app.js
  - [x] Pager prev=ch01, next=ch03
  - [x] Sections meet depth: objectives; 2.1–2.5; examples; compare/contrast; analogy
  - [x] Practice (4 tasks) with success criteria; Mastery (6 Qs) with sample answers
  - [x] ≥2 figures: client-server-seq.svg, protocols-spectrum.svg, chat-sequence.svg under /assets
  - [x] ≥8 glossary-style terms via <abbr> or glossary link
  - [x] Recap + Next steps
  - [x] All <img> paths point to ../assets/*
  -->
</body>
</html>
