<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Ch. 3 — Storage & Databases Fundamentals</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="Why we use databases, SQL vs. NoSQL, modeling, indexes, replication, and consistency trade-offs with examples and a case study.">
  <meta property="og:title" content="Chapter 3 — Storage & Databases Fundamentals">
  <meta property="og:description" content="Choose between relational and NoSQL stores, design schemas, understand indexes, and reason about replication and consistency.">
  <base href="../">
  <link rel="stylesheet" href="styles/theme.css">
  <script src="scripts/app.js" defer></script>
</head>
<body>
  <a class="skip-link" href="#main">Skip to content</a>

  <!-- Canonical Navigation (copy verbatim across all pages) -->
  <nav class="app-nav">
    <div class="container inner">
      <div class="brand">System Design (Beginner)</div>
      <button class="toggle js-nav-toggle" aria-expanded="false" aria-controls="site-menu" aria-label="Toggle menu">☰ Menu</button>
      <div id="site-menu" class="menu" role="navigation" aria-label="Primary">
        <a href="index.html">Home</a>
        <a href="chapters/ch01.html">Chapters</a>
        <a href="chapters/appendix.html">Appendix</a>
        <a href="chapters/glossary.html">Glossary</a>
      </div>
    </div>
  </nav>

  <header class="page-hero" id="top">
    <div class="container">
      <div class="meta">
        <span class="badge badge-primary">Chapter 3</span>
        <span class="badge">Databases</span>
      </div>
      <h1>Storage &amp; Databases Fundamentals</h1>
      <p class="abstract">This chapter helps you choose between <abbr title="Relational database management systems that enforce schemas and ACID properties">SQL</abbr> and <abbr title="A family of non-relational databases optimized for specific access patterns">NoSQL</abbr>, model data for predictable queries, use <abbr title="Data structures that accelerate lookups and ordering">indexes</abbr> effectively, and reason about <abbr title="Keeping copies of data on multiple nodes">replication</abbr> and <abbr title="Rules that govern visibility and ordering of reads/writes in distributed systems">consistency</abbr>.</p>
    </div>
  </header>

  <main id="main" class="container section">
    <section class="section" aria-labelledby="prereqs">
      <h2 id="prereqs">Prerequisites &amp; Learning Objectives</h2>
      <div class="grid two">
        <div class="card">
          <h3 class="mt-0">Prerequisites</h3>
          <ul>
            <li>Comfort reading JSON and basic SQL (<code>SELECT</code>/<code>INSERT</code>).</li>
            <li>Familiarity with Chapter 2’s client–server flow.</li>
          </ul>
        </div>
        <div class="card">
          <h3 class="mt-0">Objectives</h3>
          <ul>
            <li>Explain why production systems use databases rather than files.</li>
            <li>Differentiate <strong>relational</strong> vs. <strong>NoSQL</strong> data models and pick one for a given workload.</li>
            <li>Use <abbr title="B-tree or hash structures that speed up lookups and sorting">indexes</abbr> to meet latency goals and avoid full scans.</li>
            <li>Describe replication topologies and how they affect <abbr title="The time it takes for writes to appear on replicas">replication lag</abbr> and <abbr title="Guarantees like strong, eventual, causal consistency">consistency</abbr>.</li>
          </ul>
        </div>
      </div>
    </section>

    <figure>
      <img src="assets/sql-nosql-spectrum.svg" alt="Spectrum showing SQL (strong schema, ACID) ←→ NoSQL (flexible schema, scale-out). Example engines placed along the line." />
      <figcaption>Two ends of a spectrum: relational databases optimize for integrity and complex joins; NoSQL families optimize for specific access patterns and horizontal scale.</figcaption>
    </figure>

    <section class="section" aria-labelledby="why-db">
      <h2 id="why-db">3.1 Why We Need Databases</h2>
      <p>Databases provide durable storage, <strong>concurrency control</strong>, and efficient query execution. A naive file-based approach breaks down when multiple clients read and write concurrently, when you need random access by key, or when you must recover after a crash.</p>
      <p>Relational databases offer <abbr title="Atomicity, Consistency, Isolation, Durability">ACID</abbr> guarantees and a declarative query language (<abbr title="Structured Query Language">SQL</abbr>) so you can express “what” data you want and let the engine choose “how.” NoSQL stores trade some generality (joins, cross-row transactions) for scale and simplicity under specific access patterns.</p>
      <div class="callout info">
        <p class="mb-0"><strong>Analogy:</strong> A database is like a well-organized library with a catalog (indexes), borrowing rules (transactions), and multiple branches (replicas). A pile of PDFs on a shared disk is a closet—you’ll quickly lose track and collide with others.</p>
      </div>
      <p><strong>Example:</strong> A ride-hailing app must look up drivers within 3 km of a rider in &lt;150 ms. A geospatial index can answer distance queries efficiently; a flat file cannot without scanning.</p>
    </section>

    <section class="section" aria-labelledby="relational">
      <h2 id="relational">3.2 Relational Databases: Tables, Joins, Indexes</h2>
      <p>Relational databases store data in <strong>tables</strong> with rows and columns defined by a schema. Relationships are captured with <strong>foreign keys</strong>, and queries combine tables via <strong>joins</strong>. Normalization reduces duplication and anomalies; denormalization improves read performance for specific queries at the cost of write complexity.</p>
      <div class="grid two">
        <div class="card">
          <h3 class="mt-0">Index Primer</h3>
          <ul>
            <li><strong>B-tree indexes</strong> speed up range scans and ordering (<code>ORDER BY ts DESC</code>).</li>
            <li><strong>Hash indexes</strong> speed exact matches (<code>WHERE id = ?</code>).</li>
            <li><strong>Composite indexes</strong> serve multi-column filters; order matters (prefix rule).</li>
          </ul>
        </div>
        <div class="card">
          <h3 class="mt-0">Common Anti-patterns</h3>
          <ul>
            <li><strong>SELECT *</strong> pulling wide rows when you need two columns.</li>
            <li>Non-sargable predicates (<code>WHERE DATE(ts) = ...</code>) that defeat indexes.</li>
            <li>Missing <abbr title="A column whose values are unique and identify each row">primary keys</abbr>, making updates/replication harder.</li>
          </ul>
        </div>
      </div>
      <p><strong>Example (Messaging):</strong> Tables: <code>users</code>, <code>conversations</code>, <code>messages</code>. Indexes: <code>messages(conversation_id, created_at DESC)</code> for fetching latest messages; <code>messages(sender_id, created_at)</code> for user history. A join fetches the conversation title and participants.</p>
      <div class="callout warn">
        <span class="icon">⚖️</span>
        <strong>Trade-off:</strong> Highly normalized schemas minimize duplication but increase join cost and make caching harder. Documenting read paths first helps decide where denormalization is worth it.
      </div>
    </section>

    <section class="section" aria-labelledby="nosql">
      <h2 id="nosql">3.3 NoSQL Basics: Key-Value, Document, Wide-Column</h2>
      <p><strong>Key-Value</strong> stores map keys to opaque values, offering O(1)-ish access and massive scale. They excel at session stores, feature flags, and caching. <strong>Document</strong> stores keep JSON-like structures; they’re great when records are naturally hierarchical and when read paths align with document boundaries. <strong>Wide-column</strong> (column-family) stores arrange data by partition/cluster keys and scale linearly for time-series and large sparse datasets.</p>
      <div class="grid two">
        <figure>
          <img src="assets/nosql-families.svg" alt="Diagram of three NoSQL families: key-value, document, wide-column, with typical use cases" />
          <figcaption>Different shapes, different strengths: choose the model that matches your dominant access pattern.</figcaption>
        </figure>
        <div class="card">
          <h3 class="mt-0">Modeling Tips</h3>
          <ul>
            <li>Design from <em>queries</em> back to <em>data</em>: list your top 5 reads/writes first.</li>
            <li>Prefer immutable event records plus materialized views for read patterns.</li>
            <li>Use <abbr title="Time To Live">TTL</abbr> for ephemeral data (sessions, caches).</li>
          </ul>
        </div>
      </div>
      <table>
        <thead><tr><th>Model</th><th>Strength</th><th>Typical Use</th><th>Watch-outs</th></tr></thead>
        <tbody>
          <tr>
            <td>Key-Value</td>
            <td>Ultra-fast lookups</td>
            <td>Caching, sessions</td>
            <td>No secondary indexes; values opaque</td>
          </tr>
          <tr>
            <td>Document</td>
            <td>Flexible schema</td>
            <td>Profiles, catalogs</td>
            <td>Hot documents grow; need shard keys</td>
          </tr>
          <tr>
            <td>Wide-Column</td>
            <td>Linear scale, time-ordered</td>
            <td>Feeds, time-series</td>
            <td>Data modeling tied to access patterns</td>
          </tr>
        </tbody>
      </table>
    </section>

    <section class="section" aria-labelledby="replication">
      <h2 id="replication">3.4 Data Replication &amp; Consistency Trade-offs</h2>
      <p><strong>Replication</strong> improves <abbr title="Proportion of time a service is up">availability</abbr>, <abbr title="Probability of not losing data">durability</abbr>, and read <abbr title="Units of work per second">throughput</abbr> by having multiple copies. In <strong>leader-follower</strong> setups, writes go to a leader and are streamed to followers (async) or acknowledged after followers persist (sync). In <strong>leaderless</strong> setups, clients write to and read from multiple replicas with quorum rules.</p>
      <figure>
        <img src="assets/replication-modes.svg" alt="Diagram contrasting leader–follower replication with leaderless quorum replication" />
        <figcaption>Leader–follower suits transactional workloads and simpler semantics; leaderless with quorums suits high availability with tunable consistency.</figcaption>
      </figure>
      <div class="grid two">
        <div class="card">
          <h3 class="mt-0">Consistency Spectrum</h3>
          <ul>
            <li><strong>Strong:</strong> reads reflect the latest acknowledged write.</li>
            <li><strong>Read-your-writes:</strong> a session sees its own updates.</li>
            <li><strong>Eventual:</strong> replicas converge over time; faster but may show stale data.</li>
          </ul>
        </div>
        <div class="card">
          <h3 class="mt-0">Common Pitfalls</h3>
          <ul>
            <li>Read from followers without acknowledging replication lag → users see stale data.</li>
            <li>Cross-region synchronous commits with strict <abbr title="Serializable isolation level enforces a total order of transactions">serializable</abbr> semantics → high latency budgets blown.</li>
            <li>Ignoring <abbr title="Operations that can be retried safely without duplicating effects">idempotency</abbr> in retry logic → duplicates during failover.</li>
          </ul>
        </div>
      </div>
      <div class="callout warn">
        <strong>Trade-off:</strong> Synchronous replication increases durability/consistency but adds write latency and can reduce availability if a replica stalls. Asynchronous replication improves availability and write latency but risks data loss on failover (RPO &gt; 0).
      </div>
    </section>

    <section class="section" aria-labelledby="case">
      <h2 id="case">Case Study: Designing Storage for a Messaging App (≈200 words)</h2>
      <p>Goal: deliver conversation lists quickly and message threads in chronological order with low latency. <strong>Choice:</strong> Use a relational database for user, conversation, and message tables because we require transactions for message sends and deduplication, plus flexible querying for search and moderation.</p>
      <p><strong>Schema:</strong> <code>conversations(id, title, created_at)</code>, <code>participants(conversation_id, user_id, joined_at)</code>, <code>messages(id, conversation_id, sender_id, body, created_at, dedupe_key)</code>. Indexes on <code>messages(conversation_id, created_at DESC)</code> and <code>participants(user_id, conversation_id)</code>. For the inbox screen, we maintain a <em>materialized view</em> <code>inbox(user_id, conversation_id, last_msg_ts, unread_count, snippet)</code> updated on write via triggers or a background worker to avoid expensive runtime joins.</p>
      <p><strong>Replication:</strong> Leader-follower with async replication; reads for timelines served from followers with <em>read-your-writes</em> stickiness when a user sends a new message. <strong>Consistency:</strong> Eventual for the inbox (unread counts may lag &lt;2s), strong for message creation/deduplication. <strong>Scale-out:</strong> Shard by <code>conversation_id</code> once a single node’s IO or storage approaches limits; a lookup service maps conversations to shards. <strong>Caching:</strong> Hot threads cached with short TTL to reduce DB read load.</p>
    </section>

    <section class="section" aria-labelledby="resources">
      <h2 id="resources">Resources</h2>
      <ul class="resource-list">
        <li class="item">
          <div>
            <a class="external" href="https://www.postgresql.org/docs/current/index.html" target="_blank">PostgreSQL Documentation</a>
            <div class="meta">Reliable reference for schemas, indexes, transactions, and replication features.</div>
          </div>
          <span class="badge">Relational</span>
        </li>
        <li class="item">
          <div>
            <a class="external" href="https://www.mongodb.com/docs/" target="_blank">MongoDB Manual</a>
            <div class="meta">Document modeling patterns, shard keys, and aggregation pipelines.</div>
          </div>
          <span class="badge">Document</span>
        </li>
        <li class="item">
          <div>
            <a class="external" href="https://cassandra.apache.org/doc/latest/" target="_blank">Apache Cassandra Docs</a>
            <div class="meta">Wide-column data modeling, consistency levels, and partitioning.</div>
          </div>
          <span class="badge">Wide-Column</span>
        </li>
      </ul>
    </section>

    <section class="section practice" aria-labelledby="practice">
      <div class="title">Practice <span class="badge">35–60 min</span></div>
      <h2 id="practice" class="mt-1">Hands-on Tasks</h2>
      <ol>
        <li><strong>Pick a store (10–15 min).</strong> For your capstone (e.g., URL shortener), choose SQL or NoSQL and justify with two sentences focusing on access patterns. <em>Success:</em> Decision references concrete reads/writes and expected scale.</li>
        <li><strong>Design a schema (15–20 min).</strong> Draft tables/collections for your app. Include 2–3 indexes aligned to the top queries. <em>Success:</em> No query needs a full scan for common paths.</li>
        <li><strong>Add replication (10–15 min).</strong> Describe your replication mode and what consistency clients should expect (strong vs. eventual) for each read. <em>Success:</em> Clear expectations for lag and failure modes.</li>
        <li><strong>Measure a query (optional, 10–15 min).</strong> Run an EXPLAIN (or equivalent) to confirm an index is used. <em>Success:</em> Plan shows index scan rather than sequential scan.</li>
      </ol>
    </section>

    <section class="section mastery" aria-labelledby="mastery">
      <div class="title">Mastery Check <span class="badge">Self-assessment</span></div>
      <h2 id="mastery" class="mt-1">Questions (with sample answers)</h2>

      <details>
        <summary>1) When should you choose a relational database over a document store?</summary>
        <div class="pad-2">
          <p><strong>Sample answer:</strong> When you need multi-row transactions, strong integrity constraints, complex joins, or unpredictable ad-hoc queries that benefit from a mature optimizer.</p>
        </div>
      </details>

      <details>
        <summary>2) Give an example where a document store is a better fit than SQL.</summary>
        <div class="pad-2">
          <p><strong>Sample answer:</strong> Product catalogs with nested variants and optional attributes where reads fetch whole documents and writes modify a single product at a time.</p>
        </div>
      </details>

      <details>
        <summary>3) What is a composite index and why does column order matter?</summary>
        <div class="pad-2">
          <p><strong>Sample answer:</strong> An index over multiple columns (e.g., <code>(conversation_id, created_at)</code>). The engine can efficiently search prefixes of the index; putting <code>conversation_id</code> first supports equality on that column plus range on <code>created_at</code>.</p>
        </div>
      </details>

      <details>
        <summary>4) Describe a failure mode with asynchronous replication.</summary>
        <div class="pad-2">
          <p><strong>Sample answer:</strong> If the leader fails before followers receive the latest writes, a failover can lose those writes (non-zero RPO). Clients may see missing messages or counters.</p>
        </div>
      </details>

      <details>
        <summary>5) What does “read-your-writes” mean and how can you implement it?</summary>
        <div class="pad-2">
          <p><strong>Sample answer:</strong> A user should see their recent changes immediately. Implement by routing the user to the leader for a bounded time after a write or by using session stickiness/consistent prefix reads.</p>
        </div>
      </details>

      <details>
        <summary>6) Why might denormalization improve performance, and what risk does it bring?</summary>
        <div class="pad-2">
          <p><strong>Sample answer:</strong> Denormalization makes reads cheaper by storing pre-joined or aggregated data, but it risks data drift if multiple copies get out of sync; you need reliable write paths or background jobs to maintain it.</p>
        </div>
      </details>

      <details>
        <summary>7) Define durability vs. availability.</summary>
        <div class="pad-2">
          <p><strong>Sample answer:</strong> Durability is the probability data isn’t lost once acknowledged; availability is the fraction of time you can successfully read/write. Replication and backups improve durability; redundancy and failover improve availability.</p>
        </div>
      </details>
    </section>

    <section class="section" aria-labelledby="recap">
      <h2 id="recap">Recap &amp; Next Steps</h2>
      <p><strong>Recap:</strong> You learned core data models (relational, key-value, document, wide-column), how indexes shape performance, and how replication/consistency choices affect user experience. You practiced designing schema and replication plans driven by access patterns.</p>
      <p><strong>Next:</strong> In <a href="chapters/ch04.html">Chapter 4</a>, we accelerate read paths with caching: browser, CDN, and server-side caches—plus the tricky part: invalidation.</p>
    </section>

    <nav class="next-prev" aria-label="Chapter pager">
      <a rel="prev" href="chapters/ch02.html">Previous: Clients, Servers &amp; Communication</a>
      <a rel="next" href="chapters/ch04.html">Next: Caching &amp; Performance Basics</a>
    </nav>
  </main>

  <footer class="site-footer">
    <div class="container">
      <p class="mb-0">© 2025 System Design (Beginner). Chapter 3.</p>
    </div>
  </footer>

  <!--
  CHECKLIST (do not remove)
  - [x] /styles/theme.css + /scripts/app.js linked (paths correct for /chapters/)
  - [x] <base href="../"> present & correct
  - [x] Canonical nav verbatim; active link via app.js
  - [x] Pager prev=ch02, next=ch04
  - [x] Sections meet depth: 3.1–3.4 + examples, compare/contrast, analogy
  - [x] Practice (3–4 tasks) with time + success criteria
  - [x] Mastery (6–7 Qs) with sample answers
  - [x] ≥2 figures under /assets: sql-nosql-spectrum.svg, nosql-families.svg, replication-modes.svg
  - [x] ≥8 glossary-style terms via <abbr> (ACID, SQL, NoSQL, index, replication, consistency, availability, durability, serializable)
  - [x] Recap + Next steps
  -->
</body>
</html>
